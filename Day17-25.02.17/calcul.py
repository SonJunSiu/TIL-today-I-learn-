# 계산기 연산순위가 높은 연산이 앞에 온다.
# icp ( * / == 2) (+ - == 1) ( () >> 3)

# is p ( */ ==2 ) (+ - == 1) ( () >> 0)

# 1. 피연산자 출력
# 2. 연산자는 우선순위 높은애들 다 빼고 push


# ( 6 + 5 * ( 2 - 8 ) / 2) # ) 닫는 괄호가 나오면 여는 괄호 나올때 까지 다 연산
#
# 6528
#
#
# )
# /
# )
# -
# (
# *    >>>>
# +
# (

# 후위 표기법
# 우선순위가 높은 연산자가 먼저 나오는 방법
# 2 + 4 * 3  243*+
# 괄호는 다른 연산자 보다 먼저 계산되어야 하는데 괄호안의 연산자는 괄호가 처리되기 전에 먼저 연산되어야한다.
# (괄호를 읽을 때는 우선순위가 높은데) ( 이미 읽혀진 괄호는 처리가 늦게 되어야한다)
# icp(in-coming priority)
icp = {
    '*' : 2, '/' : 2, '+' : 1, '-':1, '(' : 3 # 우선순위 매기기
 }
#isp(in stack priority
isp = {
    '*' : 2, '/' : 2, '+' : 1, '-':1, '(' : 0
}
exp = '(6+5*(2-8)/2)'
stack = []
for chr in exp : # 토큰 하나씩 읽어오기
    # !!!!!!!!!!!!!!!!!!!!!!!!연산자의 우선순위가 높은게 먼저 나와야한다!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    if chr in '0123456789': # 읽은게 숫자다
        print(chr, end=' ')
    elif chr == ')': # 닫히는 괄호라면 여는 괄혹라 나올 때 까지 pop하면서 연산자 출력
        while stack[-1] != '(':
            print(stack.pop(), end='')
            # 여는 괄호는 버리기


    else : # 연산자라면 스택에 넣어야 한다.
        # 근데... 우선순위가 높은애는 뺴고 넣어야 한다.
        if not stack :  # 스택이 비어 있으면 그냥 넣으면 된다
            stack.append(chr)
        else : # 스택이 비어있지 않다면 ch보다 우선순위가 높거나 같은 연산자는 출력하고 스택에 ch를 push
            while stack and isp[stack[-1]] >= icp[chr] :
                stack.pop()
            stack.append(chr)

while stack: # 남아있는 연산자 모두 출력
    print(stack.pop(), end='')



